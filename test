0123456789

cat test^C[?2004l
ut2 >> out3
cat test >> out3 > out1 > out2

cat < test >> out3 > out1 > out2
cat < test > out1 > out2 >> out3

cat < test  | grep something > outfile > out2 | wc -l < out2

/usr/bin/ls -al | grep M
< test | grep 01

gerer si c'est directement un path qui est donne
si $ < test
si $ > out

cas : cat | wc -l < test

le infile se refert a la premiere commande
sortie sur dernier outfile

Metacharacters :
space, tab, newline
| & ; ( ) < > ; $

?? $ pas sure

Single quote -> ne pas intrepreter les meta
Double quote -> same sauf pour $

valgrind --suppressions=readline.supp --track-fds=yes --leak-check=full --show-leak-kinds=all --track-origins=yes ./minishell

COMMANDES POSSIBLES :

> out1 ls
ls > out1

< out1 cat
< out1 > out2 cat > out3

> out1
> ls    --> ca creer un fichier ls

POURQUOI CA CA MARCHE ??
< out1 > cat ls >out4
< out1 > cat touch out5

POUR LES QUOTES AU LIEU DE SPLIT SUR LES QUOTES ON PEUT 
AVANCER TANT QUE ON A PAS LA DERNIERE (SACHNAT QU"ON A VERIFIE AVANT SI DOUBLE OU PAS)
(SACHANT QUE POSITION = DERNIERE LETTRE D'UN MOT)

A FAIRE 
NE PAS OUBLIER DE RECUOP VAR ENV


GERER 
>>|<<
echo hola > > bonjour
echo hola < < bonjour
cat >> > >> << >>


biiltin moi :
cd 
export 
env 


echo "jdhfkjsdhfkjdh" sdjkjdhfk 'djkfh  ksjdfh' "jkdhfj kdh" dfsdf 'kdjlkdf  sd' > test


cat /etc/passwd | cut -d: -f1 | sed -n '2~2p' | rev | sort -r | sed -n "$FT_LINE1","$FT_LINE2"p | tr '\n' ',' | sed -n 's/,/, /gp' | sed -n 's/, $/./p' | tr -d '\n'

gerer < out cat
gerer redirection avant commande


< out cat > lsdkfjlkj | kd
cat test | ls

ls > cat > cat > catdsadas < out1

valgrind --suppressions=readline.supp --track-fds=yes --leak-check=full --show-leak-kinds=all --track-origins=yes ./minishell
